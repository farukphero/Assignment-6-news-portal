<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trusty News Network</title>
      <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">


</head>
<body>
  <header class="container">
    <h1 class="text-center text-primary">Welcome to know necessary questions answer !!</h1>
  </header>
  <main>
    <section class="container mt-5">
      <div class="accordion accordion-flush" id="accordionFlushExample">
        <div class="accordion-item">
          <h2 class="accordion-header" id="flush-headingOne">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
              data-bs-target="#flush-collapseOne" aria-expanded="false" aria-controls="flush-collapseOne">
            <b>Difference Between var, let, and const in JavaScript :</b>
            </button>
          </h2>
          <div id="flush-collapseOne" class="accordion-collapse collapse" aria-labelledby="flush-headingOne"
            data-bs-parent="#accordionFlushExample">
            <div class="accordion-body"><b>Var</b>:
            Before the advent of ES6, var declarations ruled. There are issues associated with variables declared with var, though.
            That is why it was necessary for new ways to declare variables to emerge. First, let's get to understand var more before
            we discuss those issues.
              <code>var variables can be re-declared and updated</code> <br>
            <b>Let:</b>
            let is now preferred for variable declaration. It's no surprise as it comes as an improvement to var declarations. It
            also solves the problem with var that we just covered. Let's consider why this is so.
            
            let is block scoped
            A block is a chunk of code bounded by {}. A block lives in curly braces. Anything within curly braces is a block.
            <code>let can be updated but not re-declared.</code><br>
            <b>Const</b>
            Variables declared with the const maintain constant values. const declarations share some similarities with let
            declarations.
            <code>const declarations are block scoped and const cannot be updated or re-declared.</code>
          </div>
          </div>
        </div>
        <div class="accordion-item">
          <h2 class="accordion-header" id="flush-headingTwo">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
              data-bs-target="#flush-collapseTwo" aria-expanded="false" aria-controls="flush-collapseTwo">
               <b>The Difference Between Regular Functions and Arrow Functions</b>
            </button>
          </h2>
          <div id="flush-collapseTwo" class="accordion-collapse collapse" aria-labelledby="flush-headingTwo"
            data-bs-parent="#accordionFlushExample">
            <div class="accordion-body"><b>1. Regular function</b>
            Inside of a regular JavaScript function, this value (aka the execution context) is dynamic.
            
            The dynamic context means that the value of this depends on how the function is invoked. In JavaScript, there are 4 ways
            you can invoke a regular function.
            
            During a simple invocation the value of this equals to the global object (or undefined if the function runs in strict
            mode): 
            <br>
            <code>declaration of normal function</code><br>
            function myFunction() {<br>
            console.log(this);<br>
            } <br>
            myFunction();
            <br>
            <br>
            <b>2. Arrow function</b>
            The behavior of this inside of an arrow function differs considerably from the regular function's this behavior. The
            arrow function doesn't define its own execution context.
            
            No matter how or where being executed, this value inside of an arrow function always equals this value from the outer
            function. In other words, the arrow function resolves this lexically.
            
            In the following example, myMethod() is an outer function of callback() arrow function:
            <code>declaration method</code>
             <br>
             const increment = (num) => num + 1;
               </div>
          </div>
        </div>
        <div class="accordion-item">
          <h2 class="accordion-header" id="flush-headingThree">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
              data-bs-target="#flush-collapseThree" aria-expanded="false" aria-controls="flush-collapseThree">
               <b>Difference between.forEach(), .map(), .filter() , .find()</b>
            </button>
          </h2>
          <div id="flush-collapseThree" class="accordion-collapse collapse" aria-labelledby="flush-headingThree"
            data-bs-parent="#accordionFlushExample">
            <div class="accordion-body"><b>.forEach:</b><br>
            .forEach(), is used to execute the same code on every element in an array but does not change the array and it returns
            undefined.
            <br>
            <b>.map():</b><br>
            .map() executes the same code on every element in an array and returns a new array with the updated elements.
            <br>
            <b>.filter():</b><br>
            .filter() checks every element in an array to see if it meets a certain criteria and returns a new array with the
            elements that return truthy for the criteria.
            <br>
            <b>.find()</b><br>
            .find() will look and stop after the first match.
            find() method return the first value which match from the collection. find() method search the array from the start if
            the desired value is matched then find() method return that value and terminate and rest of the array is not process.
            </div>
          </div>
        </div>
        <div class="accordion-item">
          <h2 class="accordion-header" id="flush-headingFour">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
              data-bs-target="#flush-collapseFour" aria-expanded="false" aria-controls="flush-collapseFour">
              <b>Why use template string ?</b>
            </button>
          </h2>
          <div id="flush-collapseFour" class="accordion-collapse collapse" aria-labelledby="flush-headingFour"
            data-bs-parent="#accordionFlushExample">
            <div class="accordion-body">ES6's template strings is a new way to combine strings. We already have methods such as join(), concat() etc to combine
            strings but the template strings method is the most sophisticated because itâ€™s more readable, no backslash to escape
            quotes and no more messy plus operators.
            The template strings method is used to combine strings. If we compare this method with other
            methods, the code in this method is very concise and readable.<br>
            <b>Syntax</b><br>
            <code>
              `string text line 1 <br>
              string text line 2`
            </code>
          </div>
          </div>
        </div>
      </div>
    </section>
  </main>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.min.js"
    integrity="sha384-ODmDIVzN+pFdexxHEHFBQH3/9/vQ9uori45z4JjnFsRydbmQbmL5t1tQ0culUzyK" crossorigin="anonymous"></script>

</body>
</html>